{"entityMap":{},"blocks":[{"key":"4vk2r","text":"Now that winter is here, I have decided to finish the first draft of my canbus based boiler switch.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"b4auu","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4a7bq","text":"In a previous project, I had already designed and implemented a boiler switch. This was connected to my Home-Assistant system and used Modbus instead of Canbus.  I have recently updated to a modern combi-boiler, so I now only need a relay to control the heating. I was using modbus because it was easy enough for me to creat a library myself. ","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5me9g","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3mqb6","text":"The more I looked into it, the more I started to worry about some limitations of modbus. The main issue I was starting to see was the fact that Modbus is a single-master, multi-slave system. Instead, canbus is a mulit-master sysem. This allows each node to send data as soon as the bus is free, instead of waiting for the master to request the data. ","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"42vqk","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8beiq","text":"There are many reasons why Canbus will be better than Modbus for my system. The main reason is that it allows senor data to be sent from a node to the HA system as soon as the bus is free. Since I intend to have over 100 sensors in and around my house, this should help reduce some latency in the system. For example, when a doorbell is pressed, I don't want to wait until it is polled before HA is awear that it has been pressed. Depending on the number of nodes, this could be a number of seconds before the doorbell is polled.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"13q79","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bmp6s","text":"# Canbus network","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9sab3","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"furn3","text":"For my canbus driver, I'm using the mcp2551 transiever and the mcp2515 controller.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1tt22","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ftr9i","text":"The mcp2515 is a complete SPI Canbus controller. It performs all the timing, arbitration, and other Canbus specific details. This means that I don't have to worry about implementing any of these into my PIC code. All I have to do is create a library to communicate with the mcp2515 and the controller does all the hard work for me.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ae9q5","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}]}